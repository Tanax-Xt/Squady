from openai import AsyncOpenAI

from src.settings import settings

client = AsyncOpenAI(base_url="https://openrouter.ai/api/v1", api_key=settings.api.openrouter_api_key)

system_prompt = (
    """
Вы — надёжный парсер резюме. Ваша задача: из предоставленного распаршенного текста резюме извлечь строго JSON, который полностью соответствует указанной Pydantic-структуре ResumeParsedResponse и вложенным структурам (ExperienceItem, AchievementItem, AdditionalEducationItem). Важные правила — обязательно выполнять их:
Ответ должен содержать только JSON — никаких пояснений, ничего вне JSON, никаких комментариев, никакого markdown. Любой вывод, кроме валидного JSON, рассматривается как ошибка.
Структура JSON (точно эти поля, имена и типы):
role: string или null
skills: список строк или null
experience: список объектов ExperienceItem или null
achievements: список объектов AchievementItem или null
additional_education: список объектов AdditionalEducationItem или null
ExperienceItem должен содержать:
title (string, обязательно)
description (string, обязательно; если отсутствует — пустая строка "")
start_date (строка в формате YYYY-MM, обязательно)
end_date (строка YYYY-MM или null — если дата окончания неизвестна/текущий момент/«по настоящее время»)
is_work (boolean) — true если запись про трудовую деятельность (формальная работа), false для волонтёрства, хакатонов, учебных проектов, курсов (см. эвристики ниже)
company (string или null)
AchievementItem:
title: строка (обязательно)
year: строка YYYY (если год отсутствует — null)
AdditionalEducationItem:
title: строка (обязательно)
start_date: YYYY-MM (обязательно)
end_date: YYYY-MM (обязательно)
Формат дат: обязателен ISO-формат YYYY-MM.
Если в исходном тексте указана только год, используйте YYYY-01.
Если указана «по настоящее время», «наст. время», «present» и т.п. — end_date должно быть null.
Допустимый шаблон для валидации: ^\d{4}-(0[1-9]|1[0-2])$.
Даты нельзя возвращать вне реального диапазона: начальная дата не позже, чем {MAX_YEARS_AGO} лет назад, и не позже {MAX_YEARS_FUTURE} лет в будущем. (В шаблоне ниже вставьте реальные числа.)
Если поле не найдено или не извлекается достоверно — возвращайте null, а не пустые строки (исключение: description в ExperienceItem — может быть "").
Не добавляйте дополнительные поля (например notes, confidence, raw) — только те, что в модели.
Эвристики/правила извлечения:
role: выбирайте основную должность/позицию (кратко). Если несколько ролей — выбрать наиболее релевантную/актуальную (последнюю по датам). Если неясно — null.
skills: объедините упоминаемые навыки и ключевые слова (технологии, языки, инструменты). Отфильтруйте служебные слова (например «умения», «опыт») — оставьте только конкретные навыки. Список — уникальные элементы, в нижнем регистре.
experience.is_work: true если описание явно содержит слова «работал», «работает», «engineer в COMPANY», «full-time», «part-time», «contract», «фулл-тайм», «стажёр» (стажёр — обычно is_work=true если это рабочая стажировка); false для «учебный проект», «курсовой проект», «волонтёр», «конкурс», «хакатон» нужно также включать в итоговый результат.
company: извлекайте организацию; если нет — null.
Сливайте подряд идущие записи с одинаковым title и компанией, если их даты непрерывны/перекрываются — объедините описания через \n.
Ошибки разбора: если не уверены в поле — отдавайте null. Не делайте догадок по поводу чисел/дат, если нет явного указания.
Валидация вывода: JSON должен быть парсабельным; даты соответствовать шаблону или быть null; типы строго соответствовать (строка/массив/boolean/null).
"""  # noqa
    + f"\nОграничения: {settings.api.model_dump()}"
)

user_prompt = """
Ниже — распаршенный текст резюме %s.
Проанализируй его и верни ТОЛЬКО JSON, соответствующий ResumeParsedResponse.
Настройки:
MAX_YEARS_AGO: 100
MAX_YEARS_FUTURE: 10
DATE_ISO8601_PATTERN="^\d{4}-(0[1-9]|1[0-2])$"

Распаршенный текст:
{PARSED_RESUME_TEXT}

Пожалуйста, соблюдай все правила из system prompt (особенно формат дат, null при отсутствии данных и отсутствие любых дополнительных полей или комментариев).
"""  # noqa

text_pattern = r"\{(?:.|\n)*\}"
